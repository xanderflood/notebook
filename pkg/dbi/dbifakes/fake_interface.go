// Code generated by counterfeiter. DO NOT EDIT.
package dbifakes

import (
	"context"
	"sync"

	"github.com/xanderflood/notebook/pkg/dbi"
	"github.com/xanderflood/notebook/pkg/models"
)

type FakeInterface struct {
	GetItemsStub        func(ctx context.Context, userUUID string, nextToken string) ([]models.Item, string, error)
	getItemsMutex       sync.RWMutex
	getItemsArgsForCall []struct {
		ctx       context.Context
		userUUID  string
		nextToken string
	}
	getItemsReturns struct {
		result1 []models.Item
		result2 string
		result3 error
	}
	getItemsReturnsOnCall map[int]struct {
		result1 []models.Item
		result2 string
		result3 error
	}
	GetEntriesStub        func(ctx context.Context, userUUID string, nextToken string) ([]models.Entry, string, error)
	getEntriesMutex       sync.RWMutex
	getEntriesArgsForCall []struct {
		ctx       context.Context
		userUUID  string
		nextToken string
	}
	getEntriesReturns struct {
		result1 []models.Entry
		result2 string
		result3 error
	}
	getEntriesReturnsOnCall map[int]struct {
		result1 []models.Entry
		result2 string
		result3 error
	}
	GetItemStub        func(ctx context.Context, userUUID string, uuid string) (models.Item, error)
	getItemMutex       sync.RWMutex
	getItemArgsForCall []struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}
	getItemReturns struct {
		result1 models.Item
		result2 error
	}
	getItemReturnsOnCall map[int]struct {
		result1 models.Item
		result2 error
	}
	GetEntryStub        func(ctx context.Context, userUUID string, uuid string) (models.Entry, error)
	getEntryMutex       sync.RWMutex
	getEntryArgsForCall []struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}
	getEntryReturns struct {
		result1 models.Entry
		result2 error
	}
	getEntryReturnsOnCall map[int]struct {
		result1 models.Entry
		result2 error
	}
	CreateItemStub        func(ctx context.Context, userUUID string, item models.Item) (models.Item, error)
	createItemMutex       sync.RWMutex
	createItemArgsForCall []struct {
		ctx      context.Context
		userUUID string
		item     models.Item
	}
	createItemReturns struct {
		result1 models.Item
		result2 error
	}
	createItemReturnsOnCall map[int]struct {
		result1 models.Item
		result2 error
	}
	CreateEntryStub        func(ctx context.Context, userUUID string, entry models.Entry) (models.Entry, error)
	createEntryMutex       sync.RWMutex
	createEntryArgsForCall []struct {
		ctx      context.Context
		userUUID string
		entry    models.Entry
	}
	createEntryReturns struct {
		result1 models.Entry
		result2 error
	}
	createEntryReturnsOnCall map[int]struct {
		result1 models.Entry
		result2 error
	}
	UpdateItemStub        func(ctx context.Context, userUUID string, item models.Item) (models.Item, error)
	updateItemMutex       sync.RWMutex
	updateItemArgsForCall []struct {
		ctx      context.Context
		userUUID string
		item     models.Item
	}
	updateItemReturns struct {
		result1 models.Item
		result2 error
	}
	updateItemReturnsOnCall map[int]struct {
		result1 models.Item
		result2 error
	}
	UpdateEntryStub        func(ctx context.Context, userUUID string, entry models.Entry) (models.Entry, error)
	updateEntryMutex       sync.RWMutex
	updateEntryArgsForCall []struct {
		ctx      context.Context
		userUUID string
		entry    models.Entry
	}
	updateEntryReturns struct {
		result1 models.Entry
		result2 error
	}
	updateEntryReturnsOnCall map[int]struct {
		result1 models.Entry
		result2 error
	}
	DeleteItemStub        func(ctx context.Context, userUUID string, uuid string) error
	deleteItemMutex       sync.RWMutex
	deleteItemArgsForCall []struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}
	deleteItemReturns struct {
		result1 error
	}
	deleteItemReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEntryStub        func(ctx context.Context, userUUID string, uuid string) error
	deleteEntryMutex       sync.RWMutex
	deleteEntryArgsForCall []struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}
	deleteEntryReturns struct {
		result1 error
	}
	deleteEntryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInterface) GetItems(ctx context.Context, userUUID string, nextToken string) ([]models.Item, string, error) {
	fake.getItemsMutex.Lock()
	ret, specificReturn := fake.getItemsReturnsOnCall[len(fake.getItemsArgsForCall)]
	fake.getItemsArgsForCall = append(fake.getItemsArgsForCall, struct {
		ctx       context.Context
		userUUID  string
		nextToken string
	}{ctx, userUUID, nextToken})
	fake.recordInvocation("GetItems", []interface{}{ctx, userUUID, nextToken})
	fake.getItemsMutex.Unlock()
	if fake.GetItemsStub != nil {
		return fake.GetItemsStub(ctx, userUUID, nextToken)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getItemsReturns.result1, fake.getItemsReturns.result2, fake.getItemsReturns.result3
}

func (fake *FakeInterface) GetItemsCallCount() int {
	fake.getItemsMutex.RLock()
	defer fake.getItemsMutex.RUnlock()
	return len(fake.getItemsArgsForCall)
}

func (fake *FakeInterface) GetItemsArgsForCall(i int) (context.Context, string, string) {
	fake.getItemsMutex.RLock()
	defer fake.getItemsMutex.RUnlock()
	return fake.getItemsArgsForCall[i].ctx, fake.getItemsArgsForCall[i].userUUID, fake.getItemsArgsForCall[i].nextToken
}

func (fake *FakeInterface) GetItemsReturns(result1 []models.Item, result2 string, result3 error) {
	fake.GetItemsStub = nil
	fake.getItemsReturns = struct {
		result1 []models.Item
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetItemsReturnsOnCall(i int, result1 []models.Item, result2 string, result3 error) {
	fake.GetItemsStub = nil
	if fake.getItemsReturnsOnCall == nil {
		fake.getItemsReturnsOnCall = make(map[int]struct {
			result1 []models.Item
			result2 string
			result3 error
		})
	}
	fake.getItemsReturnsOnCall[i] = struct {
		result1 []models.Item
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetEntries(ctx context.Context, userUUID string, nextToken string) ([]models.Entry, string, error) {
	fake.getEntriesMutex.Lock()
	ret, specificReturn := fake.getEntriesReturnsOnCall[len(fake.getEntriesArgsForCall)]
	fake.getEntriesArgsForCall = append(fake.getEntriesArgsForCall, struct {
		ctx       context.Context
		userUUID  string
		nextToken string
	}{ctx, userUUID, nextToken})
	fake.recordInvocation("GetEntries", []interface{}{ctx, userUUID, nextToken})
	fake.getEntriesMutex.Unlock()
	if fake.GetEntriesStub != nil {
		return fake.GetEntriesStub(ctx, userUUID, nextToken)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getEntriesReturns.result1, fake.getEntriesReturns.result2, fake.getEntriesReturns.result3
}

func (fake *FakeInterface) GetEntriesCallCount() int {
	fake.getEntriesMutex.RLock()
	defer fake.getEntriesMutex.RUnlock()
	return len(fake.getEntriesArgsForCall)
}

func (fake *FakeInterface) GetEntriesArgsForCall(i int) (context.Context, string, string) {
	fake.getEntriesMutex.RLock()
	defer fake.getEntriesMutex.RUnlock()
	return fake.getEntriesArgsForCall[i].ctx, fake.getEntriesArgsForCall[i].userUUID, fake.getEntriesArgsForCall[i].nextToken
}

func (fake *FakeInterface) GetEntriesReturns(result1 []models.Entry, result2 string, result3 error) {
	fake.GetEntriesStub = nil
	fake.getEntriesReturns = struct {
		result1 []models.Entry
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetEntriesReturnsOnCall(i int, result1 []models.Entry, result2 string, result3 error) {
	fake.GetEntriesStub = nil
	if fake.getEntriesReturnsOnCall == nil {
		fake.getEntriesReturnsOnCall = make(map[int]struct {
			result1 []models.Entry
			result2 string
			result3 error
		})
	}
	fake.getEntriesReturnsOnCall[i] = struct {
		result1 []models.Entry
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeInterface) GetItem(ctx context.Context, userUUID string, uuid string) (models.Item, error) {
	fake.getItemMutex.Lock()
	ret, specificReturn := fake.getItemReturnsOnCall[len(fake.getItemArgsForCall)]
	fake.getItemArgsForCall = append(fake.getItemArgsForCall, struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}{ctx, userUUID, uuid})
	fake.recordInvocation("GetItem", []interface{}{ctx, userUUID, uuid})
	fake.getItemMutex.Unlock()
	if fake.GetItemStub != nil {
		return fake.GetItemStub(ctx, userUUID, uuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getItemReturns.result1, fake.getItemReturns.result2
}

func (fake *FakeInterface) GetItemCallCount() int {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	return len(fake.getItemArgsForCall)
}

func (fake *FakeInterface) GetItemArgsForCall(i int) (context.Context, string, string) {
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	return fake.getItemArgsForCall[i].ctx, fake.getItemArgsForCall[i].userUUID, fake.getItemArgsForCall[i].uuid
}

func (fake *FakeInterface) GetItemReturns(result1 models.Item, result2 error) {
	fake.GetItemStub = nil
	fake.getItemReturns = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) GetItemReturnsOnCall(i int, result1 models.Item, result2 error) {
	fake.GetItemStub = nil
	if fake.getItemReturnsOnCall == nil {
		fake.getItemReturnsOnCall = make(map[int]struct {
			result1 models.Item
			result2 error
		})
	}
	fake.getItemReturnsOnCall[i] = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) GetEntry(ctx context.Context, userUUID string, uuid string) (models.Entry, error) {
	fake.getEntryMutex.Lock()
	ret, specificReturn := fake.getEntryReturnsOnCall[len(fake.getEntryArgsForCall)]
	fake.getEntryArgsForCall = append(fake.getEntryArgsForCall, struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}{ctx, userUUID, uuid})
	fake.recordInvocation("GetEntry", []interface{}{ctx, userUUID, uuid})
	fake.getEntryMutex.Unlock()
	if fake.GetEntryStub != nil {
		return fake.GetEntryStub(ctx, userUUID, uuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getEntryReturns.result1, fake.getEntryReturns.result2
}

func (fake *FakeInterface) GetEntryCallCount() int {
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	return len(fake.getEntryArgsForCall)
}

func (fake *FakeInterface) GetEntryArgsForCall(i int) (context.Context, string, string) {
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	return fake.getEntryArgsForCall[i].ctx, fake.getEntryArgsForCall[i].userUUID, fake.getEntryArgsForCall[i].uuid
}

func (fake *FakeInterface) GetEntryReturns(result1 models.Entry, result2 error) {
	fake.GetEntryStub = nil
	fake.getEntryReturns = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) GetEntryReturnsOnCall(i int, result1 models.Entry, result2 error) {
	fake.GetEntryStub = nil
	if fake.getEntryReturnsOnCall == nil {
		fake.getEntryReturnsOnCall = make(map[int]struct {
			result1 models.Entry
			result2 error
		})
	}
	fake.getEntryReturnsOnCall[i] = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) CreateItem(ctx context.Context, userUUID string, item models.Item) (models.Item, error) {
	fake.createItemMutex.Lock()
	ret, specificReturn := fake.createItemReturnsOnCall[len(fake.createItemArgsForCall)]
	fake.createItemArgsForCall = append(fake.createItemArgsForCall, struct {
		ctx      context.Context
		userUUID string
		item     models.Item
	}{ctx, userUUID, item})
	fake.recordInvocation("CreateItem", []interface{}{ctx, userUUID, item})
	fake.createItemMutex.Unlock()
	if fake.CreateItemStub != nil {
		return fake.CreateItemStub(ctx, userUUID, item)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createItemReturns.result1, fake.createItemReturns.result2
}

func (fake *FakeInterface) CreateItemCallCount() int {
	fake.createItemMutex.RLock()
	defer fake.createItemMutex.RUnlock()
	return len(fake.createItemArgsForCall)
}

func (fake *FakeInterface) CreateItemArgsForCall(i int) (context.Context, string, models.Item) {
	fake.createItemMutex.RLock()
	defer fake.createItemMutex.RUnlock()
	return fake.createItemArgsForCall[i].ctx, fake.createItemArgsForCall[i].userUUID, fake.createItemArgsForCall[i].item
}

func (fake *FakeInterface) CreateItemReturns(result1 models.Item, result2 error) {
	fake.CreateItemStub = nil
	fake.createItemReturns = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) CreateItemReturnsOnCall(i int, result1 models.Item, result2 error) {
	fake.CreateItemStub = nil
	if fake.createItemReturnsOnCall == nil {
		fake.createItemReturnsOnCall = make(map[int]struct {
			result1 models.Item
			result2 error
		})
	}
	fake.createItemReturnsOnCall[i] = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) CreateEntry(ctx context.Context, userUUID string, entry models.Entry) (models.Entry, error) {
	fake.createEntryMutex.Lock()
	ret, specificReturn := fake.createEntryReturnsOnCall[len(fake.createEntryArgsForCall)]
	fake.createEntryArgsForCall = append(fake.createEntryArgsForCall, struct {
		ctx      context.Context
		userUUID string
		entry    models.Entry
	}{ctx, userUUID, entry})
	fake.recordInvocation("CreateEntry", []interface{}{ctx, userUUID, entry})
	fake.createEntryMutex.Unlock()
	if fake.CreateEntryStub != nil {
		return fake.CreateEntryStub(ctx, userUUID, entry)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createEntryReturns.result1, fake.createEntryReturns.result2
}

func (fake *FakeInterface) CreateEntryCallCount() int {
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	return len(fake.createEntryArgsForCall)
}

func (fake *FakeInterface) CreateEntryArgsForCall(i int) (context.Context, string, models.Entry) {
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	return fake.createEntryArgsForCall[i].ctx, fake.createEntryArgsForCall[i].userUUID, fake.createEntryArgsForCall[i].entry
}

func (fake *FakeInterface) CreateEntryReturns(result1 models.Entry, result2 error) {
	fake.CreateEntryStub = nil
	fake.createEntryReturns = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) CreateEntryReturnsOnCall(i int, result1 models.Entry, result2 error) {
	fake.CreateEntryStub = nil
	if fake.createEntryReturnsOnCall == nil {
		fake.createEntryReturnsOnCall = make(map[int]struct {
			result1 models.Entry
			result2 error
		})
	}
	fake.createEntryReturnsOnCall[i] = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) UpdateItem(ctx context.Context, userUUID string, item models.Item) (models.Item, error) {
	fake.updateItemMutex.Lock()
	ret, specificReturn := fake.updateItemReturnsOnCall[len(fake.updateItemArgsForCall)]
	fake.updateItemArgsForCall = append(fake.updateItemArgsForCall, struct {
		ctx      context.Context
		userUUID string
		item     models.Item
	}{ctx, userUUID, item})
	fake.recordInvocation("UpdateItem", []interface{}{ctx, userUUID, item})
	fake.updateItemMutex.Unlock()
	if fake.UpdateItemStub != nil {
		return fake.UpdateItemStub(ctx, userUUID, item)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateItemReturns.result1, fake.updateItemReturns.result2
}

func (fake *FakeInterface) UpdateItemCallCount() int {
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	return len(fake.updateItemArgsForCall)
}

func (fake *FakeInterface) UpdateItemArgsForCall(i int) (context.Context, string, models.Item) {
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	return fake.updateItemArgsForCall[i].ctx, fake.updateItemArgsForCall[i].userUUID, fake.updateItemArgsForCall[i].item
}

func (fake *FakeInterface) UpdateItemReturns(result1 models.Item, result2 error) {
	fake.UpdateItemStub = nil
	fake.updateItemReturns = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) UpdateItemReturnsOnCall(i int, result1 models.Item, result2 error) {
	fake.UpdateItemStub = nil
	if fake.updateItemReturnsOnCall == nil {
		fake.updateItemReturnsOnCall = make(map[int]struct {
			result1 models.Item
			result2 error
		})
	}
	fake.updateItemReturnsOnCall[i] = struct {
		result1 models.Item
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) UpdateEntry(ctx context.Context, userUUID string, entry models.Entry) (models.Entry, error) {
	fake.updateEntryMutex.Lock()
	ret, specificReturn := fake.updateEntryReturnsOnCall[len(fake.updateEntryArgsForCall)]
	fake.updateEntryArgsForCall = append(fake.updateEntryArgsForCall, struct {
		ctx      context.Context
		userUUID string
		entry    models.Entry
	}{ctx, userUUID, entry})
	fake.recordInvocation("UpdateEntry", []interface{}{ctx, userUUID, entry})
	fake.updateEntryMutex.Unlock()
	if fake.UpdateEntryStub != nil {
		return fake.UpdateEntryStub(ctx, userUUID, entry)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateEntryReturns.result1, fake.updateEntryReturns.result2
}

func (fake *FakeInterface) UpdateEntryCallCount() int {
	fake.updateEntryMutex.RLock()
	defer fake.updateEntryMutex.RUnlock()
	return len(fake.updateEntryArgsForCall)
}

func (fake *FakeInterface) UpdateEntryArgsForCall(i int) (context.Context, string, models.Entry) {
	fake.updateEntryMutex.RLock()
	defer fake.updateEntryMutex.RUnlock()
	return fake.updateEntryArgsForCall[i].ctx, fake.updateEntryArgsForCall[i].userUUID, fake.updateEntryArgsForCall[i].entry
}

func (fake *FakeInterface) UpdateEntryReturns(result1 models.Entry, result2 error) {
	fake.UpdateEntryStub = nil
	fake.updateEntryReturns = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) UpdateEntryReturnsOnCall(i int, result1 models.Entry, result2 error) {
	fake.UpdateEntryStub = nil
	if fake.updateEntryReturnsOnCall == nil {
		fake.updateEntryReturnsOnCall = make(map[int]struct {
			result1 models.Entry
			result2 error
		})
	}
	fake.updateEntryReturnsOnCall[i] = struct {
		result1 models.Entry
		result2 error
	}{result1, result2}
}

func (fake *FakeInterface) DeleteItem(ctx context.Context, userUUID string, uuid string) error {
	fake.deleteItemMutex.Lock()
	ret, specificReturn := fake.deleteItemReturnsOnCall[len(fake.deleteItemArgsForCall)]
	fake.deleteItemArgsForCall = append(fake.deleteItemArgsForCall, struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}{ctx, userUUID, uuid})
	fake.recordInvocation("DeleteItem", []interface{}{ctx, userUUID, uuid})
	fake.deleteItemMutex.Unlock()
	if fake.DeleteItemStub != nil {
		return fake.DeleteItemStub(ctx, userUUID, uuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteItemReturns.result1
}

func (fake *FakeInterface) DeleteItemCallCount() int {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	return len(fake.deleteItemArgsForCall)
}

func (fake *FakeInterface) DeleteItemArgsForCall(i int) (context.Context, string, string) {
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	return fake.deleteItemArgsForCall[i].ctx, fake.deleteItemArgsForCall[i].userUUID, fake.deleteItemArgsForCall[i].uuid
}

func (fake *FakeInterface) DeleteItemReturns(result1 error) {
	fake.DeleteItemStub = nil
	fake.deleteItemReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) DeleteItemReturnsOnCall(i int, result1 error) {
	fake.DeleteItemStub = nil
	if fake.deleteItemReturnsOnCall == nil {
		fake.deleteItemReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteItemReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) DeleteEntry(ctx context.Context, userUUID string, uuid string) error {
	fake.deleteEntryMutex.Lock()
	ret, specificReturn := fake.deleteEntryReturnsOnCall[len(fake.deleteEntryArgsForCall)]
	fake.deleteEntryArgsForCall = append(fake.deleteEntryArgsForCall, struct {
		ctx      context.Context
		userUUID string
		uuid     string
	}{ctx, userUUID, uuid})
	fake.recordInvocation("DeleteEntry", []interface{}{ctx, userUUID, uuid})
	fake.deleteEntryMutex.Unlock()
	if fake.DeleteEntryStub != nil {
		return fake.DeleteEntryStub(ctx, userUUID, uuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteEntryReturns.result1
}

func (fake *FakeInterface) DeleteEntryCallCount() int {
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	return len(fake.deleteEntryArgsForCall)
}

func (fake *FakeInterface) DeleteEntryArgsForCall(i int) (context.Context, string, string) {
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	return fake.deleteEntryArgsForCall[i].ctx, fake.deleteEntryArgsForCall[i].userUUID, fake.deleteEntryArgsForCall[i].uuid
}

func (fake *FakeInterface) DeleteEntryReturns(result1 error) {
	fake.DeleteEntryStub = nil
	fake.deleteEntryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) DeleteEntryReturnsOnCall(i int, result1 error) {
	fake.DeleteEntryStub = nil
	if fake.deleteEntryReturnsOnCall == nil {
		fake.deleteEntryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEntryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getItemsMutex.RLock()
	defer fake.getItemsMutex.RUnlock()
	fake.getEntriesMutex.RLock()
	defer fake.getEntriesMutex.RUnlock()
	fake.getItemMutex.RLock()
	defer fake.getItemMutex.RUnlock()
	fake.getEntryMutex.RLock()
	defer fake.getEntryMutex.RUnlock()
	fake.createItemMutex.RLock()
	defer fake.createItemMutex.RUnlock()
	fake.createEntryMutex.RLock()
	defer fake.createEntryMutex.RUnlock()
	fake.updateItemMutex.RLock()
	defer fake.updateItemMutex.RUnlock()
	fake.updateEntryMutex.RLock()
	defer fake.updateEntryMutex.RUnlock()
	fake.deleteItemMutex.RLock()
	defer fake.deleteItemMutex.RUnlock()
	fake.deleteEntryMutex.RLock()
	defer fake.deleteEntryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbi.Interface = new(FakeInterface)
